````markdown
# 88. Merge Sorted Array

> **작성일**: 2025년 9월 25일

## 문제 설명
두 개의 정렬된 정수 배열 `nums1`과 `nums2`를 하나의 정렬된 배열로 병합하는 문제입니다.

- `nums1`의 길이는 `m + n`이며, 처음 `m`개 원소는 병합할 값들이고 마지막 `n`개는 0으로 채워져 있습니다.
- `nums2`의 길이는 `n`입니다.
- 결과는 `nums1`에 **in-place**로 저장되어야 합니다.

## 제약사항
- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

## 해결 방법

### 방법 1: 단순한 접근법 (주석 처리된 코드)
```python
nums1[:] = sorted(nums1[:m] + nums2[:n])
```

**장점:**
- 코드가 간단하고 이해하기 쉽습니다.
- 한 줄로 해결 가능합니다.

**단점:**
- **시간복잡도**: O((m+n) log(m+n)) - 정렬 때문에
- **공간복잡도**: O(m+n) - 새로운 배열 생성

### 방법 2: 투 포인터 (현재 구현)
```python
def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    p1 = m - 1      # nums1의 마지막 유효한 원소 인덱스
    p2 = n - 1      # nums2의 마지막 원소 인덱스
    p = m + n - 1   # nums1의 마지막 인덱스 (채워야 할 위치)

    # 뒤에서부터 비교하며 큰 값을 뒤쪽에 배치
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    
    # nums2에 남은 원소들 처리
    if p2 >= 0:
        nums1[:p2 + 1] = nums2[:p2 + 1]
```

**핵심 아이디어:**
- **뒤에서부터 채우기**: 앞에서부터 채우면 기존 값들이 덮어써지는 문제가 발생
- **세 개의 포인터 사용**: p1(nums1), p2(nums2), p(결과 위치)

**시간복잡도**: O(m+n) - 각 원소를 한 번씩만 확인
**공간복잡도**: O(1) - 추가 공간 사용 없음

## 알고리즘 동작 과정

### 예시: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

**초기 상태:**
```
nums1: [1, 2, 3, 0, 0, 0]
              ↑        ↑
            p1=2      p=5
nums2: [2, 5, 6]
              ↑
            p2=2
```

**Step 1:** nums1[2]=3 vs nums2[2]=6 → 6이 더 크므로
```
nums1: [1, 2, 3, 0, 0, 6]
              ↑     ↑
            p1=2   p=4
nums2: [2, 5, 6]
           ↑
         p2=1
```

**Step 2:** nums1[2]=3 vs nums2[1]=5 → 5가 더 크므로
```
nums1: [1, 2, 3, 0, 5, 6]
              ↑  ↑
            p1=2 p=3
nums2: [2, 5, 6]
        ↑
      p2=0
```

**Step 3:** nums1[2]=3 vs nums2[0]=2 → 3이 더 크므로
```
nums1: [1, 2, 3, 3, 5, 6]
           ↑  ↑
        p1=1 p=2
nums2: [2, 5, 6]
        ↑
      p2=0
```

**Step 4:** nums1[1]=2 vs nums2[0]=2 → 같으므로 nums2[0]을 선택
```
nums1: [1, 2, 2, 3, 5, 6]
        ↑  ↑
       p1=1 p=1
nums2: [2, 5, 6]
           (p2=-1, 종료)
```

## 에지 케이스 처리

### Case 1: nums2가 비어있는 경우
```python
nums1 = [1], m = 1, nums2 = [], n = 0
# 결과: [1] (변화 없음)
```

### Case 2: nums1이 비어있는 경우 (m=0)
```python
nums1 = [0], m = 0, nums2 = [1], n = 1
# nums2의 모든 원소를 nums1에 복사
```

### Case 3: nums1의 모든 원소가 nums2보다 작은 경우
```python
# while 루프가 끝난 후 p2 >= 0이면
# nums2의 남은 원소들을 앞쪽에 복사
if p2 >= 0:
    nums1[:p2 + 1] = nums2[:p2 + 1]
```

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|------------|------------|------|------|
| 정렬 | O((m+n) log(m+n)) | O(m+n) | 구현 간단 | 비효율적 |
| 투 포인터 | O(m+n) | O(1) | 최적화된 성능 | 구현 복잡 |
s
## 핵심 포인트
1. **뒤에서부터 채우기**: 기존 데이터 손실 방지
2. **투 포인터 기법**: 효율적인 병합
3. **In-place 수정**: `nums1[:]` 슬라이싱으로 같은 객체 유지
4. **에지 케이스**: nums2 남은 원소 처리

## 다른 접근법들

### 방법 3: 앞에서부터 병합 (추가 공간 사용)
```python
def merge_alternative(self, nums1, m, nums2, n):
    nums1_copy = nums1[:m]
    p1 = p2 = 0
    p = 0
    
    while p1 < m and p2 < n:
        if nums1_copy[p1] <= nums2[p2]:
            nums1[p] = nums1_copy[p1]
            p1 += 1
        else:
            nums1[p] = nums2[p2]
            p2 += 1
        p += 1
    
    # 남은 원소들 처리
    while p1 < m:
        nums1[p] = nums1_copy[p1]
        p1 += 1
        p += 1
    
    while p2 < n:
        nums1[p] = nums2[p2]
        p2 += 1
        p += 1
```

이 방법은 공간을 O(m) 사용하지만 로직이 더 직관적입니다.

## 결론
현재 구현된 **투 포인터 + 뒤에서부터 채우기** 방법이 가장 효율적입니다:
- 최적의 시간복잡도: O(m+n)
- 최적의 공간복잡도: O(1)  
- In-place 수정으로 메모리 효율적
